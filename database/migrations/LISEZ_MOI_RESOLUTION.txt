═══════════════════════════════════════════════════════════════
  RÉSOLUTION DE L'ERREUR: column "badge_type" does not exist
═══════════════════════════════════════════════════════════════

🔍 DIAGNOSTIC
─────────────────────────────────────────────────────────────
Cause: Une table user_badges EXISTE DÉJÀ dans votre base Supabase
       avec une structure différente de celle voulue.

Structure actuelle:  id, user_id, badge_id (FK), earned_at
Structure voulue:    id, user_id, badge_name, badge_type (ENUM), ...

Le fichier 003_gamification_tables.sql essaie de créer une table
avec badge_type (colonne ENUM), mais la table existe déjà avec
badge_id (INTEGER FK vers table badges).

═══════════════════════════════════════════════════════════════
  FICHIERS CRÉÉS POUR RÉSOUDRE LE PROBLÈME
═══════════════════════════════════════════════════════════════

📁 database/migrations/

1. ✅ 003_INSPECTION_AVANT_MIGRATION.sql
   → Requêtes SQL pour analyser les données existantes
   → À EXÉCUTER EN PREMIER
   → Vous dira combien de badges existent

2. ✅ 003_gamification_OPTION_A_MIGRATION.sql
   → Migration AVEC préservation des données
   → Renomme l'ancienne table → user_badges_old
   → Crée nouvelle table avec nouvelle structure
   → Migre automatiquement les données
   → Utiliser si: COUNT(user_badges) >= 10

3. ✅ 003_gamification_OPTION_B_DROP_AND_CREATE.sql
   → Migration DESTRUCTIVE (suppression + recréation)
   → Supprime les tables existantes
   → Recrée avec nouvelle structure propre
   → Utiliser si: COUNT(user_badges) < 10 ou données non importantes

4. ✅ RESOLUTION_RAPIDE_CONFLIT.md
   → Guide rapide en markdown
   → Explications courtes
   → Arbre de décision

5. ✅ GUIDE_RESOLUTION_CONFLIT.md
   → Guide complet en markdown
   → Explications détaillées
   → Exemples de requêtes

6. ✅ ETAT_MIGRATION_003.md
   → Résumé exécutif de la situation
   → Checklist complète
   → FAQ et troubleshooting

═══════════════════════════════════════════════════════════════
  PLAN D'ACTION EN 4 ÉTAPES (3 MINUTES)
═══════════════════════════════════════════════════════════════

ÉTAPE 1: INSPECTION (30 secondes)
─────────────────────────────────────────────────────────────
1. Ouvrez Supabase Dashboard
2. Allez dans SQL Editor
3. Copiez TOUT le contenu de: 003_INSPECTION_AVANT_MIGRATION.sql
4. Collez dans l'éditeur SQL
5. Exécutez
6. Notez le résultat de: SELECT COUNT(*) FROM user_badges;

ÉTAPE 2: DÉCISION (10 secondes)
─────────────────────────────────────────────────────────────
Si le COUNT est 0, 1, 2... 9:
  → Utilisez OPTION B (simple, propre)
  
Si le COUNT est 10, 20, 50, 100+:
  → Utilisez OPTION A (préserve les données)

Pas sûr? Partagez-moi le nombre et je vous conseille.

ÉTAPE 3: EXÉCUTION (1 minute)
─────────────────────────────────────────────────────────────
1. Copiez TOUT le contenu du fichier choisi:
   - Soit: 003_gamification_OPTION_A_MIGRATION.sql
   - Soit: 003_gamification_OPTION_B_DROP_AND_CREATE.sql
   
2. Dans Supabase SQL Editor, collez le script complet

3. Cliquez sur "Run" ou "Exécuter"

4. Attendez la fin complète (20-30 secondes)
   ⚠️ Ne pas interrompre pendant l'exécution

5. Vérifiez qu'aucun message d'erreur rouge n'apparaît

ÉTAPE 4: VÉRIFICATION (30 secondes)
─────────────────────────────────────────────────────────────
Exécutez ces requêtes pour confirmer:

SELECT COUNT(*) FROM user_points;    -- Doit exister
SELECT COUNT(*) FROM user_progress;  -- Doit exister
SELECT COUNT(*) FROM user_badges;    -- Doit exister

SELECT * FROM user_points LIMIT 1;   -- Voir structure

SELECT typname, enumlabel 
FROM pg_type 
JOIN pg_enum ON pg_type.oid = pg_enum.enumtypid 
WHERE typname = 'badge_type';        -- Voir ENUM badge_type

Si tout fonctionne → ✅ Migration réussie !

═══════════════════════════════════════════════════════════════
  DIFFÉRENCES ENTRE OPTION A ET OPTION B
═══════════════════════════════════════════════════════════════

OPTION A: Migration avec Préservation
─────────────────────────────────────────────────────────────
✅ Garde les badges existants
✅ Ancienne table renommée en backup (user_badges_old)
✅ Migration automatique des données
⚠️  Plus complexe
⚠️  Nécessite table 'badges' avec colonnes: name, description, icon
⏱️  Durée: ~30 secondes

Idéal si:
  • Vous avez 10+ badges attribués
  • Les badges existants sont importants
  • Vous voulez un backup automatique

OPTION B: Suppression & Recréation
─────────────────────────────────────────────────────────────
✅ Simple et propre
✅ Tables recréées avec structure correcte
✅ Aucune dépendance externe
❌ PERTE TOTALE des données existantes
⏱️  Durée: ~10 secondes

Idéal si:
  • Vous avez 0-9 badges (peu de données)
  • Les badges actuels ne sont pas importants
  • Vous voulez repartir de zéro
  • Environnement de développement/test

═══════════════════════════════════════════════════════════════
  FAQ - QUESTIONS FRÉQUENTES
═══════════════════════════════════════════════════════════════

Q: Dois-je arrêter l'application pendant la migration?
R: Non, mais les utilisateurs ne pourront pas gagner de badges
   pendant les 10-30 secondes de migration.

Q: Puis-je annuler si je me trompe?
R: Option A: Oui, la table user_badges_old contient le backup
   Option B: Non, les données sont définitivement supprimées

Q: Que faire si j'ai 5 badges?
R: Option B recommandée (peu de données à perdre)

Q: Erreur "table badges does not exist" avec Option A?
R: La table 'badges' n'existe pas dans votre base.
   Solution: Utilisez Option B à la place.

Q: Comment savoir si ça a marché?
R: Exécutez: SELECT * FROM user_points LIMIT 1;
   Si vous voyez des colonnes, c'est réussi.

Q: Puis-je exécuter les deux options?
R: NON! Choisissez UNE SEULE option (A ou B).

Q: L'ancienne migration 003_gamification_tables.sql?
R: ❌ NE PAS UTILISER - fichier obsolète avec erreurs
   Utilisez Option A ou B à la place.

═══════════════════════════════════════════════════════════════
  CE QUI SERA CRÉÉ APRÈS LA MIGRATION
═══════════════════════════════════════════════════════════════

3 Nouvelles Tables:
─────────────────────────────────────────────────────────────
1. user_points
   → Points, niveaux, streaks de chaque utilisateur
   → Colonnes: total_points, level, current_streak, etc.

2. user_progress
   → Progression dans les chapitres/leçons
   → Colonnes: chapitre_id, completed, progress_percentage, etc.

3. user_badges
   → Badges gagnés par les utilisateurs
   → Colonnes: badge_name, badge_type (ENUM), badge_icon, etc.

9 Politiques RLS (Row Level Security):
─────────────────────────────────────────────────────────────
   → Protection des données personnelles
   → Chaque utilisateur voit uniquement ses données
   → Exceptions: Leaderboard (user_points visible par tous)

4 Fonctions PostgreSQL:
─────────────────────────────────────────────────────────────
   → calculate_level(points): Calcul automatique du niveau
   → calculate_points_to_next_level(level): Points requis
   → update_user_level(): Trigger pour mise à jour auto
   → init_user_points(): Création auto pour nouveaux users

2 Triggers Automatiques:
─────────────────────────────────────────────────────────────
   → trigger_update_user_level: MAJ niveau quand points changent
   → trigger_init_user_points: Créer user_points pour nouveau profil

1 Type ENUM:
─────────────────────────────────────────────────────────────
   → badge_type: 7 valeurs possibles
     (progression, performance, streak, perfection, 
      speed, dedication, special)

═══════════════════════════════════════════════════════════════
  PROCHAINES ÉTAPES APRÈS MIGRATION RÉUSSIE
═══════════════════════════════════════════════════════════════

Phase 2 - Étape 2: Intégration React
─────────────────────────────────────────────────────────────
1. Modifier la fonction completeQuiz() pour attribuer des points
2. Implémenter l'attribution automatique de badges
3. Mettre à jour le leaderboard avec user_points
4. Afficher les badges sur les profils utilisateurs
5. Créer un système de notifications pour nouveaux badges

═══════════════════════════════════════════════════════════════
  CONTACT & SUPPORT
═══════════════════════════════════════════════════════════════

En cas de problème:
  1. Copiez le message d'erreur COMPLET
  2. Notez le code d'erreur PostgreSQL (ex: 42703, 42804)
  3. Indiquez quelle option vous avez utilisée (A ou B)
  4. Partagez-moi ces informations

Je vous aiderai à résoudre immédiatement.

═══════════════════════════════════════════════════════════════

✅ RÉSUMÉ ULTRA-RAPIDE:
  1. Exécutez: 003_INSPECTION_AVANT_MIGRATION.sql
  2. Comptez: SELECT COUNT(*) FROM user_badges;
  3. Choisissez: < 10 → Option B | >= 10 → Option A
  4. Exécutez le fichier choisi dans Supabase
  5. Vérifiez: SELECT * FROM user_points LIMIT 1;

═══════════════════════════════════════════════════════════════

📅 Date: 5 octobre 2025
✅ Statut: PRÊT À EXÉCUTER
🎯 Prochaine action: Inspection des données existantes

═══════════════════════════════════════════════════════════════
